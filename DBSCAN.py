"""
**Project: Creating an algorithm in python to extract plots and get area, shape, location, and time of cultivation using a set of coordinates generated by a GPS tracking device.**

Data Analysis:
Fetching the Data from the Excel Sheet

Read Data into Python from CSV file:
"""


import csv
import math
import pandas as pd
import numpy as np
import datetime
import matplotlib.pyplot as plt
import geopandas as gpd
from shapely.geometry import Point

"""Reading the excel data as a pandas dataframe:"""

data = pd.read_excel(r"GPS_data/original.xlsx")

"""Showing the output of dataframe:"""

data.head

"""Getting header data:"""

header = data.iloc[0,0]
print(header)
rowCount = len(data.index)
latitudeArray = []
latArr1=[]
longArr1=[]
longitudeArray = []
DataActualTime = []
DataReceivedTime = []
DataActualTimeEpoch = []
SpeedArray = []


for i in range(4, rowCount):
  latitudeArray.append(int(data.iloc[i][0])/(10**7))
  longitudeArray.append(int(data.iloc[i][1])/(10**7))
  DataActualTime.append(datetime.datetime.strptime(data.iloc[i][8], '%d-%m-%Y %H:%M:%S'))
  DataReceivedTime.append(datetime.datetime.strptime(data.iloc[i][9], '%d-%m-%Y %H:%M:%S'))  
  SpeedArray.append(int(data.iloc[i][6]))

for elem in DataActualTime:
  DataActualTimeEpoch.append(elem.timestamp())

arrayLen = len(latitudeArray)

for i in range(1, arrayLen):
  if(latitudeArray[i]!=latitudeArray[i-1]) or (longitudeArray[i]!=longitudeArray[i-1]):
    latArr1.append(latitudeArray[i])
    longArr1.append(longitudeArray[i])

"""Checking for anomalies in Actual time vs Received time:


"""

dateDiffArray = list(abs(np.array(DataActualTime)- np.array(DataReceivedTime)))

"""Displaying the data as a geoPlot:"""

geometry = [Point(xy) for xy in zip(longArr1,latArr1)]
geo_df = gpd.GeoDataFrame(geometry= geometry)
g = geo_df.plot(markersize = 0.1, color = 'red',marker = '*', figsize = (30,30))

"""Plotting a rudimentary line graph with gradient coloring of the Tractor's movement:

"""

#Line graph on Geopandas:
from matplotlib.collections import LineCollection
from matplotlib.colors import ListedColormap, BoundaryNorm


# Data manipulation:
def make_segments(x, y):
    '''
    Create list of line segments from x and y coordinates, in the correct format for LineCollection:
    an array of the form   numlines x (points per line) x 2 (x and y) array
    '''

    points = np.array([x, y]).T.reshape(-1, 1, 2)
    segments = np.concatenate([points[:-1], points[1:]], axis=1)
    
    return segments


# Interface to LineCollection:
def colorline(x, y, z=None, cmap=plt.get_cmap('copper'), norm=plt.Normalize(0.0, 1.0), linewidth=3, alpha=1.0):
    '''
    Plot a colored line with coordinates x and y
    Optionally specify colors in the array z
    Optionally specify a colormap, a norm function and a line width
    '''
    
    # Default colors equally spaced on [0,1]:
    if z is None:
        z = np.linspace(0.0, 1.0, len(x))
           
    # Special case if a single number:
    if not hasattr(z, "__iter__"):  # to check for numerical input -- this is a hack
        z = np.array([z])
        
    z = np.asarray(z)
    
    segments = make_segments(x, y)
    lc = LineCollection(segments, array=z, cmap=cmap, norm=norm, linewidth=linewidth, alpha=alpha)
    
    ax = plt.gca()
    ax.add_collection(lc)
    
    return lc



plt.figure(figsize = (30, 20))
colorline(longArr1, latArr1)
plt.xlim(min(longArr1), max(longArr1))
plt.ylim(min(latArr1), max(latArr1))
plt.show()

"""Implementing DBSCAN clustering algorithm:

"""

from sklearn.cluster import DBSCAN
from sklearn import metrics
from sklearn.mixture import GaussianMixture

scikitArray = []
for i in range (0, len(latArr1)):
  coordinates = []
  coordinates.append(latArr1[i])
  coordinates.append(longArr1[i])
  coordinates.append(DataActualTimeEpoch[i]/10**8)

  scikitArray.append(coordinates)

GmmscikitArr = scikitArray
################## Change EPS and MinPts here #######################

db = DBSCAN(eps=0.0002, min_samples=22).fit(scikitArray)

#####################################################################

#core_samples_mask = np.zeros_like(db.labels_, =bool)
#core_samples_mask[db.core_sample_indices_] = True
labels = db.labels_
 
# Number of clusters in labels
uniqueLabels = set(labels)

#Seperating the noise and the non-noise datapoints
noiseArray = []
nonnoiseArray = []

for i in range(len(labels)):
  if labels[i] == -1:
    list1 = []
    list1.append(latArr1[i])
    list1.append(longArr1[i])
    noiseArray.append(list1)
  else:
    list1 = []
    list1.append(latArr1[i])
    list1.append(longArr1[i])
    nonnoiseArray.append(list1)

plt.figure(figsize = (20,20))
plt.scatter([x[1] for x in noiseArray], [x[0] for x in noiseArray], c = 'k', s = 1)
plt.scatter([x[1] for x in nonnoiseArray], [x[0] for x in nonnoiseArray], c = 'r', s = 1)
plt.plot()
plt.show()
plt.savefig(fname = "plots.png")

"""To show number of Labels:"""

print(set(labels))

"""Seperating the unique plots, and displaying them with colour codes:"""

from collections import defaultdict
example_dictionary = defaultdict(list)

for i in range(len(scikitArray)):
  example_dictionary[labels[i]].append(scikitArray[i])

#print(' '.join(sorted(example_dictionary, key=lambda k: len(example_dictionary[k]), reverse=True)))

sorted_keys = sorted(example_dictionary, key=example_dictionary.get)
sorted_example_dictionary = {}
for key in sorted_keys:
    sorted_example_dictionary[key] = example_dictionary[key]

#plot
plt.figure(figsize = (20,20))
###### plot the required plots here, give color to 'c' parameter, and example_dictionary[i] gives plot of i'th field #######
###### add a plt.scatter(list(list(zip(*example_dictionary[i]))[1]), list(list(zip(*example_dictionary[i]))[0]), c = '<color here>', s = 1) for 
#################### each additional field 'i' in example_dictionary #######################

plt.scatter(list(list(zip(*example_dictionary[1]))[1]), list(list(zip(*example_dictionary[1]))[0]), c = 'g', s = 1)
plt.scatter(list(list(zip(*example_dictionary[2]))[1]), list(list(zip(*example_dictionary[2]))[0]), c = 'r', s = 1)
plt.scatter(list(list(zip(*example_dictionary[-1]))[1]), list(list(zip(*example_dictionary[-1]))[0]), c = 'k', s = 1)
plt.scatter(list(list(zip(*example_dictionary[3]))[1]), list(list(zip(*example_dictionary[3]))[0]), c = 'b', s = 1)

plt.plot()
plt.show()

"""Displaying the number of points per key in dictionary"""

for new_k, new_val in example_dictionary.items():
    print(new_k, len([item for item in new_val if item]))

"""Calculating Area of the plots"""

def polyarea(lats, lons, algorithm = 0, radius = 6378.137):
    
    from numpy import arctan2, cos, sin, sqrt, pi, power, append, diff, deg2rad
    lats = np.deg2rad(lats)
    lons = np.deg2rad(lons)

    if lats[0]!=lats[-1]:
        lats = append(lats, lats[0])
        lons = append(lons, lons[0])

    a = sin(lats/2)**2 + cos(lats)* sin(lons/2)**2
    colat = 2*arctan2( sqrt(a), sqrt(1-a) )
  
    az = arctan2(cos(lats) * sin(lons), sin(lats)) % (2*pi)
  
    daz = diff(az)
    daz = (daz + pi) % (2 * pi) - pi

    deltas=diff(colat)/2
    colat=colat[0:-1]+deltas
  
    integrands = (1-cos(colat)) * daz
 
    area = abs(sum(integrands))/(4*pi)

    area = min(area,1-area)
    if radius is not None:
        return area * 4*pi*radius**2
    else: 
        return area

"""For calculating the convex hull of the polygon"""

def convex_hull(points):
    
    points = sorted(set(points))

    if len(points) <= 1:
        return points

    def cross(o, a, b):
        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])
 
    lower = []
    for p in points:
        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:
            lower.pop()
        lower.append(p)

    upper = []
    for p in reversed(points):
        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:
            upper.pop()
        upper.append(p)

    return lower[:-1] + upper[:-1]

"""Displaying shape of Field:"""

plot_area={}
sorted_area=[]
reqPlots = [1,2,3]
reqPlots2 = [0]
for key in example_dictionary.keys():
  con_hull=[]
  merged_list=[]
  new_lat=[]
  new_lon=[] 
  if(key==-1):
    continue
  a=np.array(example_dictionary[key])
  if(True):
    z=[]
    x=[]
    y=[]
    for i in range(len(a)):
      new_lat.append(a[i,0])
      new_lon.append(a[i,1])
    merged_list = tuple(zip(new_lat,new_lon))
    con_hull = convex_hull(merged_list)
    for item in con_hull:
      z.append(list(item))
    for j in range(len(z)):
      x.append(z[j][0]) 
      y.append(z[j][1]) 
    area = polyarea(x,y) 
    plot_area[key]=area
    sorted_area.append(plot_area[key])
    sorted_area.sort(reverse = True)
    if key in reqPlots:
      plt.plot(x, y)
      plt.show()
    '''elif key in reqPlots2:
      plt.plot(x, y)
      plt.show()'''

"""GMM Implemetation attempt, pls ignore:"""

#-------------------------------Gaussian Mixture
#Gaussian Mixture:
gmm = GaussianMixture(n_components = 4).fit(GmmscikitArr) 
GmmLabels = gmm.predict(GmmscikitArr)
dict1 = {}
dict1['labels'] = GmmLabels
print(set(dict1['labels']))

gmmD0Arr = []
gmmD1Arr = []
gmmD2Arr = []
gmmD3Arr = []
gmmD4Arr = []

for i in range(len(dict1['labels'])):
  if dict1['labels'][i] == 0:
    list1 = []
    list1.append(latitudeArray[i])
    list1.append(longitudeArray[i])
    gmmD0Arr.append(list1)
  elif dict1['labels'][i] == 1:
    list1 = []
    list1.append(latitudeArray[i])
    list1.append(longitudeArray[i])
    gmmD1Arr.append(list1)
  elif dict1['labels'][i] == 2:
    list1 = []
    list1.append(latitudeArray[i])
    list1.append(longitudeArray[i])
    gmmD2Arr.append(list1)

print(len(gmmD0Arr),len(gmmD1Arr), len(gmmD2Arr), end = '\n')
plt.figure(figsize = (20,20))
plt.scatter([x[1] for x in gmmD0Arr], [x[0] for x in gmmD0Arr], c ='r', s = 2)
plt.scatter([x[1] for x in gmmD1Arr], [x[0] for x in gmmD1Arr], c ='blue', s = 2)
plt.scatter([x[1] for x in gmmD2Arr], [x[0] for x in gmmD2Arr], c ='g', s = 2)

plt.plot()
plt.show()

sorted_area